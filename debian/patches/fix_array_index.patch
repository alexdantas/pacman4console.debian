Description: Fix array index out of bounds if pacman or ghost is going
             through one border to the opposite site.
Author: Yannic Scheper <ys42@cd42.de>
Last-Update: 20110915
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' pacman4console-1.2~/pacman.c pacman4console-1.2/pacman.c
--- pacman4console-1.2~/pacman.c	2006-12-14 05:51:58.000000000 +0100
+++ pacman4console-1.2/pacman.c	2011-09-15 00:18:28.765403666 +0200
@@ -226,6 +226,7 @@
 void GetInput() {
 	int ch;
 	static int chtmp;
+	int tmp;
 
 	ch = getch();
 
@@ -235,26 +236,34 @@
 
 	switch (ch) {
 		case KEY_UP:    case 'w': case 'W':
-			if((Level[Loc[4][0] - 1][Loc[4][1]] != 1)
-			&& (Level[Loc[4][0] - 1][Loc[4][1]] != 4))
+			if(Loc[4][0] == 0) tmp = 28;
+			else tmp = Loc[4][0] - 1;
+			if((Level[tmp][Loc[4][1]] != 1)
+			&& (Level[tmp][Loc[4][1]] != 4))
 				{ Dir[4][0] = -1; Dir[4][1] =  0; }
 			break;
 
 		case KEY_DOWN:  case 's': case 'S':
-			if((Level[Loc[4][0] + 1][Loc[4][1]] != 1)
-			&& (Level[Loc[4][0] + 1][Loc[4][1]] != 4))
+			if(Loc[4][0] == 28) tmp = 0;
+			else tmp = Loc[4][0] + 1;
+			if((Level[tmp][Loc[4][1]] != 1)
+			&& (Level[tmp][Loc[4][1]] != 4))
 				{ Dir[4][0] =  1; Dir[4][1] =  0; }
 			break;
 
 		case KEY_LEFT:  case 'a': case 'A':
-			if((Level[Loc[4][0]][Loc[4][1] - 1] != 1)
-			&& (Level[Loc[4][0]][Loc[4][1] - 1] != 4))
+			if(Loc[4][1] == 0) tmp = 27;
+			else tmp = Loc[4][1] - 1;
+			if((Level[Loc[4][0]][tmp] != 1)
+			&& (Level[Loc[4][0]][tmp] != 4))
 				{ Dir[4][0] =  0; Dir[4][1] = -1; }
 			break;
 
 		case KEY_RIGHT: case 'd': case 'D':
-			if((Level[Loc[4][0]][Loc[4][1] + 1] != 1)
-			&& (Level[Loc[4][0]][Loc[4][1] + 1] != 4))
+			if(Loc[4][1] == 27) tmp = 0;
+			else tmp = Loc[4][1] + 1;
+			if((Level[Loc[4][0]][tmp] != 1)
+			&& (Level[Loc[4][0]][tmp] != 4))
 				{ Dir[4][0] =  0; Dir[4][1] =  1; }
 			break;
 
@@ -424,6 +433,7 @@
 	int tmpdx = 0; int tmpdy = 0;
 	int checksides[] = { 0, 0, 0, 0, 0, 0 };
 	static int SlowerGhosts = 0;
+	int tmp;
 
 	if(Invincible == 1) {
 		SlowerGhosts++;
@@ -445,10 +455,18 @@
 
 		//Determine which directions we can go
 		for(b = 0; b < 4; b++) checksides[b] = 0;
-		if(Level[Loc[a][0] + 1][Loc[a][1]] != 1) checksides[0] = 1;
-		if(Level[Loc[a][0] - 1][Loc[a][1]] != 1) checksides[1] = 1;
-		if(Level[Loc[a][0]][Loc[a][1] + 1] != 1) checksides[2] = 1;
-		if(Level[Loc[a][0]][Loc[a][1] - 1] != 1) checksides[3] = 1;
+		if(Loc[a][0] == 28) tmp = 0;
+		else tmp = Loc[a][0] + 1;
+		if(Level[tmp][Loc[a][1]] != 1) checksides[0] = 1;
+		if(Loc[a][0] == 0) tmp = 28;
+		else tmp = Loc[a][0] - 1;
+		if(Level[tmp][Loc[a][1]] != 1) checksides[1] = 1;
+		if(Loc[a][1] == 27) tmp = 0;
+		else tmp = Loc[a][1] + 1;
+		if(Level[Loc[a][0]][tmp] != 1) checksides[2] = 1;
+		if(Loc[a][1] == 0) tmp = 27;
+		else tmp = Loc[a][1] - 1;
+		if(Level[Loc[a][0]][tmp] != 1) checksides[3] = 1;
 
 		//Don't do 180 unless we have to
 		c = 0; for(b = 0; b < 4; b++) if(checksides[b] == 1) c++;
